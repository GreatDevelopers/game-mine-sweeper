<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"> <title>Minesweeper</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .grid {
            display: grid; /* Use grid layout */
            padding: 10px;
            grid-template-columns: repeat(10, 30px); /* Matches GRID_SIZE */
            /* Rows will be created automatically based on cell height */
            background-color: #ccc;
            border: 2px solid #999;
            margin-bottom: 10px;
        }
        .cell {
            width: 30px;
            height: 30px;
            border: 1px solid #999;
            background-color: #bbb; /* Slightly darker default */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            user-select: none; /* Prevent text selection */
            box-shadow: inset 1px 1px 2px white, inset -1px -1px 2px #888; /* Basic bevel */
        }
        .cell:active {
             box-shadow: inset -1px -1px 2px white, inset 1px 1px 2px #888; /* Pressed effect */
        }
        .revealed {
            background-color: #ddd;
            cursor: default;
            box-shadow: none; /* Flat when revealed */
             border: 1px solid #ccc; /* Lighter border when revealed */
        }
        .mine {
            background-color: red;
            color: black; /* Ensure mine symbol is visible */
        }
        .flagged::after {
             content: '🚩'; /* Flag emoji - Requires UTF-8 */
             font-size: 18px;
        }
        /* Add colors for numbers */
        .c1 { color: blue; }
        .c2 { color: green; }
        .c3 { color: red; }
        .c4 { color: purple; }
        .c5 { color: maroon; }
        .c6 { color: turquoise; }
        .c7 { color: black; }
        .c8 { color: gray; }

        #status {
            margin-top: 10px;
            font-size: 1.2em;
        }
        button {
            margin-top: 10px;
            padding: 5px 10px;
            font-size: 1em;
        }
    </style>
</head>
<body>
    <h1>Minesweeper</h1>
    <div id="status">Mines: <span id="mine-count"></span> | Flags: <span id="flag-count">0</span></div>
    <div id="minesweeper" class="grid"></div>
    <button onclick="resetGame()">Reset Game</button>

    <script>
        const GRID_SIZE = 10;
        const MINE_COUNT = 10;

        let grid = []; // Stores 'M' for mine, or number of adjacent mines
        let revealed = new Set(); // Stores 'x,y' keys of revealed cells
        let flagged = new Set(); // Stores 'x,y' keys of flagged cells
        let gameOver = false;
        let firstClick = true; // Ensure first click is never a mine

        const boardElement = document.getElementById('minesweeper');
        let mineCountElement = document.getElementById('mine-count'); // Use 'let' as it might be reassigned in reset
        let flagCountElement = document.getElementById('flag-count'); // Use 'let' as it might be reassigned in reset
        const statusElement = document.getElementById('status');


        function createGridData() {
            // Create empty grid data structure
            grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                grid[y] = new Array(GRID_SIZE).fill(0);
            }
            // Mines will be placed after the first click
        }

        function placeMines(firstClickX, firstClickY) {
            let minesPlaced = 0;
            while (minesPlaced < MINE_COUNT) {
                const x = Math.floor(Math.random() * GRID_SIZE);
                const y = Math.floor(Math.random() * GRID_SIZE);

                // Don't place a mine on the first clicked cell or its immediate neighbors
                const isStartArea = Math.abs(x - firstClickX) <= 1 && Math.abs(y - firstClickY) <= 1;

                if (grid[y][x] !== 'M' && !isStartArea) {
                    grid[y][x] = 'M';
                    minesPlaced++;
                }
                 // Add a safeguard against infinite loops if somehow all valid spots are filled except the start area
                 // This is unlikely with typical grid/mine counts but good practice
                 if (minesPlaced < MINE_COUNT && (GRID_SIZE * GRID_SIZE - minesPlaced) <= 9 && isStartArea) {
                     // If few spots left and we keep hitting the start area, try placing anywhere not 'M'
                     if (grid[y][x] !== 'M') {
                         grid[y][x] = 'M';
                         minesPlaced++;
                     }
                 }
            }

             // Calculate numbers based on adjacent mines
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === 'M') continue;
                    let count = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue; // Skip self
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < GRID_SIZE && nx >= 0 && nx < GRID_SIZE && grid[ny][nx] === 'M') {
                                count++;
                            }
                        }
                    }
                    grid[y][x] = count;
                }
            }
        }


        function revealCell(x, y) {
            if (gameOver || x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
            const key = `${x},${y}`;
            if (revealed.has(key) || flagged.has(key)) return; // Don't reveal flagged or already revealed cells

             // Ensure first click isn't a mine
            if (firstClick) {
                placeMines(x, y); // Place mines *after* knowing the first click location
                firstClick = false;
            }

            const cellElement = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (!cellElement) return; // Safety check

            revealed.add(key);
            cellElement.classList.add('revealed');
            cellElement.classList.remove('flagged'); // Remove flag if it was revealed

            // Clear potential emoji content from flag before setting text/number
            cellElement.innerHTML = '';

            if (grid[y][x] === 'M') {
                // Game Over - Loss
                cellElement.classList.add('mine');
                cellElement.innerHTML = '💣'; // Mine emoji - Requires UTF-8
                endGame(false); // Pass false for loss
                return;
            }

            if (grid[y][x] > 0) {
                cellElement.textContent = grid[y][x];
                cellElement.classList.add(`c${grid[y][x]}`); // Add color class
            } else {
                 // Flood fill for cells with 0 adjacent mines
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                         if (dx === 0 && dy === 0) continue; // Don't recurse on the same cell
                        revealCell(x + dx, y + dy);
                    }
                }
            }
            checkWin();
        }

        function flagCell(x, y) {
            if (gameOver || x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
             const key = `${x},${y}`;
             if (revealed.has(key)) return; // Can't flag revealed cells

             const cellElement = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
             if (!cellElement) return; // Safety check

             if (flagged.has(key)) {
                 flagged.delete(key);
                 cellElement.classList.remove('flagged');
                 // The ::after pseudo-element handles the flag display, no need to set innerHTML here normally
                 // cellElement.innerHTML = ''; // Clear potential emoji text if needed
             } else {
                 flagged.add(key);
                 cellElement.classList.add('flagged');
                 // Clear text content in case a number was somehow there before flagging
                 cellElement.textContent = '';
             }
             updateFlagCount();
        }

        function updateFlagCount() {
            if (flagCountElement) {
                 flagCountElement.textContent = flagged.size;
            }
        }

        function checkWin() {
            const totalCells = GRID_SIZE * GRID_SIZE;
            // Win if the number of revealed cells equals total cells minus the number of mines
            if (revealed.size === totalCells - MINE_COUNT) {
                if (!gameOver) {
                    endGame(true); // Pass true for win
                }
            }
        }

         function endGame(isWin) {
            if (gameOver) return; // Prevent running multiple times
            gameOver = true;
            revealAllMines(isWin);
            if (isWin) {
                statusElement.textContent = '🎉 You Win! 🎉'; // Requires UTF-8
            } else {
                 statusElement.textContent = '💥 Game Over! 💥'; // Requires UTF-8
            }
        }

        function revealAllMines(isWin) {
             for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const key = `${x},${y}`;
                    const cellElement = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                    if (!cellElement) continue;

                    // Handle mines
                    if (grid[y][x] === 'M') {
                        if (!revealed.has(key) && !(isWin && flagged.has(key))) {
                             cellElement.classList.remove('flagged');
                             cellElement.classList.add('revealed');
                             cellElement.classList.add('mine');
                             cellElement.innerHTML = '💣'; // Requires UTF-8
                        }
                        else if (isWin && flagged.has(key)) {
                             cellElement.classList.add('c2');
                             // Optional: explicitly show checkmark or leave flag
                             // cellElement.innerHTML = '✔️'; // Requires UTF-8
                        }
                    }
                    // Handle incorrectly flagged cells (only if player lost)
                    else if (!isWin && flagged.has(key)) {
                        cellElement.classList.remove('flagged');
                        cellElement.classList.add('revealed');
                        cellElement.innerHTML = '❌'; // Requires UTF-8
                    }
                }
            }
        }


        function createBoardDOM() {
            boardElement.innerHTML = ''; // Clear previous board if any
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    // Left Click
                    cell.addEventListener('click', () => revealCell(x, y));

                    // Right Click (Context Menu)
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault(); // Prevent browser context menu
                        flagCell(x, y);
                    });

                    boardElement.appendChild(cell);
                }
            }
        }

        function resetGame() {
            grid = [];
            revealed.clear();
            flagged.clear();
            gameOver = false;
            firstClick = true;
            statusElement.innerHTML = `Mines: <span id="mine-count">${MINE_COUNT}</span> | Flags: <span id="flag-count">0</span>`; // Reset status text too

            // Re-assign these elements after resetting innerHTML
            mineCountElement = document.getElementById('mine-count');
            flagCountElement = document.getElementById('flag-count');

            createGridData(); // Prepare the data array
            createBoardDOM(); // Create the visual cells
            updateFlagCount(); // Set initial flag count display to 0
            if (mineCountElement) {
                 mineCountElement.textContent = MINE_COUNT; // Display mine count
            }
        }

        // Initialize Game on Load
        resetGame();

    </script>
</body>
</html>
